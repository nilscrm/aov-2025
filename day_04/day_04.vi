
use #util::{Cell, Recv, Send, Stream};
use #root::data::Array;
use #root::data::Iterator::Fused;

pub fn main(&io: &IO) {
  let grid = List::empty;

  let first = io.read_byte('.');
  let prev = Cell::new(first);
  let first_row = [];
  for c in io.read_line().assume().iter() {
    let cell = Cell::new(c);
    prev.connect(&cell);
    first_row.push_back(prev);
    prev = cell;
  }
  first_row.push_back(prev);

  let prev_row = first_row;
  while io.read_line() is Some(line) {
    let row = [];
    let prev_iter = Fused::new(prev_row.iter_ref());
    let nw = None();
    let n = prev_iter.next();
    let ne = prev_iter.next();
    let w = None();

    for c in line.iter() {
      let cell = Cell::new(c);
      if nw is Some(nw) {
        cell.connect(nw);
      }
      if n is Some(n) {
        cell.connect(n);
      }
      if ne is Some(ne) {
        cell.connect(ne);
      }
      if w is Some(w) {
        cell.connect(&w);
        row.push_back(w);
      } else {}
      (nw, n, ne) = (n, ne, prev_iter.next());
      w = Some(cell);
    }
    row.push_back(w.assume());
    grid.push_back(prev_row);
    prev_row = row;
  }
  grid.push_back(prev_row);

  let part1 = 0;
  let part2 = 0;
  loop {
    let prev = part2;
    for &row in grid.iter_ref() {
      for &Cell({ data, in_edges, out_edges }) in row.iter_ref() {
        for &o in out_edges.iter_ref() {
          o.send_stream(data);
        }
        let neighbors = 0;
        for &i in in_edges.iter_ref() {
          if i.recv_stream() == '@' {
            neighbors += 1;
          }
        }
        if data == '@' and neighbors < 4 {
          part2 += 1;
          data = 'x';
        }
      }
    }
    if part1 == 0 {
      part1 = part2;
    }
    if prev != part2 {
      continue;
    }
  }

  io.println("Part 1: {part1}");
  io.println("Part 2: {part2}");

  unsafe::erase(grid);
}


use #util::UnionFind;
use #root::data::Heap;

pub fn main(&io: &IO) {
  let edges = Heap::empty;

  let points = [];
  let i = 0;
  while io.read_line() is Some(line) {
    let nums = line.split(",");
    let x = N32::parse(nums.pop_front().assume()).assume();
    let y = N32::parse(nums.pop_front().assume()).assume();
    let z = N32::parse(nums.pop_front().assume()).assume();

    for (j, &(x2, y2, z2)) in points.iter_ref().enumerate() {
      let dist = 0[N64];
      let diff = if x <= x2 {
        x2 - x
      } else {
        x - x2
      };
      dist += N64::mul_n32_n32(diff, diff);
      let diff = if y <= y2 {
        y2 - y
      } else {
        y - y2
      };
      dist += N64::mul_n32_n32(diff, diff);
      let diff = if z <= z2 {
        z2 - z
      } else {
        z - z2
      };
      dist += N64::mul_n32_n32(diff, diff);
      edges.insert((dist, i, j));
    }

    points.push_back((x, y, z));
    i += 1;
  }

  let components = UnionFind::new((0..i).collect[List, _, _]());

  let connections_todo = points.len() - 1;

  for _ in 0..1000 {
    let (_, i, j) = edges.pop().assume();
    if components.union(&i, &j) {
      connections_todo -= 1;
    }
  }

  let max = [(0, N32::maximum), (0, N32::maximum), (0, N32::maximum)];

  for i in 0..points.len() {
    let (size, component) = components.find(&i);
    for &(s, c) in &max {
      if c == component {
        break;
      }
      if size > s {
        swap(&(s, c), &(size, component));
      }
    }
  }

  let part1 = N64::mul_n32_n32(max.pop_front().assume().0, max.pop_front().assume().0) * max.pop_front().assume().0;

  io.println("Part 1: {part1}");

  loop {
    let (_, i, j) = edges.pop().assume();
    if components.union(&i, &j) {
      connections_todo -= 1;
    }
    if connections_todo == 0 {
      let x1 = points.at(i).assume().*.0;
      let x2 = points.at(j).assume().*.0;
      let part2 = N64::mul_n32_n32(x1, x2);
      io.println("Part 2: {part2}");
    } else {
      continue;
    }
  }
}
